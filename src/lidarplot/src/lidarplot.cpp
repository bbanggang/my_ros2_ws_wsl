/*
 * SLLIDAR ROS2 CLIENT
 *
 * Copyright (c) 2009 - 2014 RoboPeak Team
 * http://www.robopeak.com
 * Copyright (c) 2014 - 2022 Shanghai Slamtec Co., Ltd.
 * http://www.slamtec.com
 *
 */

#include "rclcpp/rclcpp.hpp"
#include "sensor_msgs/msg/laser_scan.hpp"
#include <cmath>
#include <math.h>
// OpenCV 라이브러리 추가
#include <opencv2/opencv.hpp>
#include <rclcpp/executors.hpp>
#include <rclcpp/node.hpp>

#define RAD2DEG(x) ((x)*180./M_PI)

// 동영상 저장을 위한 Writer 객체와 초기화 플래그 (static으로 선언)
static cv::VideoWriter video_writer;
static bool is_video_init = false;

static void scanCb(sensor_msgs::msg::LaserScan::SharedPtr scan) {
  int count = scan->scan_time / scan->time_increment;
  
  // 안전을 위해 ranges 사이즈로 count 재설정 (데이터 개수 불일치 방지)
  if(scan->ranges.size() > 0) count = scan->ranges.size();

  printf("[SLLIDAR INFO]: I heard a laser scan %s[%d]:\n", scan->header.frame_id.c_str(), count);
  printf("[SLLIDAR INFO]: angle_range : [%f, %f]\n", RAD2DEG(scan->angle_min),
         RAD2DEG(scan->angle_max));

  // 1. 스캔 영상 그리기 준비 (500x500 검은색 배경)
  cv::Mat image(500, 500, CV_8UC3, cv::Scalar(255, 255, 255));
  
  // 중심점 좌표
  cv::Point center(250, 250);

  // 십자가 그리기 (흰색, 중심 표시)
  cv::line(image, cv::Point(250, 245), cv::Point(250, 255), cv::Scalar(0, 0, 0), 1);
  cv::line(image, cv::Point(245, 250), cv::Point(255, 250), cv::Scalar(0, 0, 0), 1);

  // 거리 환산 비율 설정: 10m가 500px이므로, 반경 5m가 250px에 해당.
  // 즉, 1m = 50px 입니다.
  double scale = 50.0; 

  for (int i = 0; i < count; i++) {
    // float degree = RAD2DEG(scan->angle_min + scan->angle_increment * i);
    
    // 거리 데이터 (m 단위)
    float distance = scan->ranges[i];
    float angle_rad = scan->angle_min + scan->angle_increment * i;
    

    // 유효한 거리 데이터인지 확인
    if (std::isfinite(distance) && distance > 0) {
        
        // x: 오른쪽이 증가 (+ sin)
        // y: 위쪽이 감소 (- cos) -> 0도가 위를 향함
        int x = 250 + (int)(distance * scale * sin(angle_rad));
        
        int y = 250 + (int)(distance * scale * cos(angle_rad));


        // if(angle_rad >= -3.141592 && angle_rad <= -(3.141592 / 2.0)){
        //     std::cout <<  "sector 1 : " <<(int)(distance * scale * cos(angle_rad)) << std::endl;
        //     std::cout << y << std::endl;
        // }
        // else if (-(3.141592 / 2.0) <= angle_rad && angle_rad <= 0.0) {
        //     std::cout <<  "sector 2 : " <<(int)(distance * scale * cos(angle_rad)) << std::endl;
        //     std::cout << y << std::endl;
            
        // }
        // else if ( 0.0 <= angle_rad && angle_rad <= 3.141592 / 2.0) {
        //     std::cout <<  "sector 3 : " <<(int)(distance * scale * cos(angle_rad)) << std::endl;
        //     std::cout << y << std::endl;
            
        // }
        // else if( 3.141592 / 2.0  <= angle_rad  && angle_rad <= 3.141592)  {
        //     std::cout <<  "sector 4 : " <<(int)(distance * scale * cos(angle_rad)) << std::endl;
        //     std::cout << y << std::endl;
        // }


        // 이미지 범위 내에 있는지 확인 후 그리기
        if (x >= 0 && x < 500 && y >= 0 && y < 500) {
            cv::circle(image, cv::Point(x, y), 2, cv::Scalar(0, 0, 255), -1);
        }


    }
    // 터미널 출력은 너무 많으므로 주석 처리하거나 필요시 유지
    // printf("[SLLIDAR INFO]: angle-distance : [%f, %f]\n", degree, scan->ranges[i]);
  }

  // 화면에 영상 출력
  cv::imshow("LIDAR Scan", image);
  cv::waitKey(1); // 1ms 대기 (화면 갱신을 위해 필수)

  // 동영상 저장 코드
  if (!is_video_init) {
      // 파일명, 코덱, FPS, 해상도 설정
      video_writer.open("/home/linux/ros2_ws/video/scan_video.mp4", cv::VideoWriter::fourcc('M', 'J', 'P', 'G'), 10, cv::Size(500, 500), true);
      is_video_init = true;
      printf("[SLLIDAR INFO]: Video recording started.\n");
  }

  if (video_writer.isOpened()) {
      video_writer.write(image);
  }
}

int main(int argc, char **argv) {
  rclcpp::init(argc, argv);

  auto node = rclcpp::Node::make_shared("sllidar_client");

  auto lidar_info_sub = node->create_subscription<sensor_msgs::msg::LaserScan>(
                        "scan", rclcpp::SensorDataQoS(), scanCb);

  rclcpp::spin(node);

  rclcpp::shutdown();

  // 종료 시 비디오 파일 닫기
  if (video_writer.isOpened()) {
      video_writer.release();
  }

  return 0;
}